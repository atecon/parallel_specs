function void display_workers_output (const int n_jobs,
                                      const bool debugging)
    /* Print results of workers. */

    loop i=1..n_jobs -q
        printf "Info: Output for argument set %d:\n", i

        string filename = sprintf("PS_output_%d.txt", i)
        catch printf "%s", readfile(filename)
        if $error
            printf "Error: Could not read file %s.", filename
        endif

        remove_file(filename, debugging)
    endloop
end function


function void remove_file (const string filename,
                           const bool debugging)
    /* Remove temporary output file. */

    if !debugging
        catch remove(filename)
        if $error
            printf "Warning: Problem removing file %s", filename
        endif
    endif
end function


function bundles create_output_array (const strings filenames_bundles,
                                      const bool debugging)
    /* Assemble the returned array. */

    print "Info: Assembling bundles for return."
    bundles B = array(nelem(filenames_bundles))

    loop foreach i filenames_bundles -q
        catch B[i] = bread(filenames_bundles[i])
        if $error
            printf "Failed to read bundle file %s.\n", filenames_bundles[i]
        endif
        remove_file(filenames_bundles[i], debugging)
    endloop

    return B
end function


function scalar has_mpi_support (void)
    /* Check that MPI is installed. */

    if !$sysinfo.mpi
        printf "Error: No MPI support present, Aborting."
        return 0
    else
        return 1
    endif
end function


function scalar njobs_exceeds_nproc (const int n_jobs)
    /* */
    # FIXME: Why does this fail? We could loop over subsets of n_jobs
    if n_jobs > $sysinfo.nproc
        printf "Error: Number of bundles passed (%d) exceeds\n\
          available processors (%d), Aborting.", n_jobs, $sysinfo.nproc
        return 1
    else
        return 0
    endif
end function


function strings write_arg_bundles (const bundles ArgBundles)
/* Write out bundles containing the argument sets.
    return: array of filenames written. */

    strings filenames_bundles = array(nelem(ArgBundles))
    loop i=1..nelem(ArgBundles) -q
        filenames_bundles[i] = sprintf("PS_bundle_%d.xml", i)
        catch bwrite(ArgBundles[i], filenames_bundles[i])

        if $error
            printf "Error: Failed to write bundle %d to\n\
              %s. Abort.", $i, filenames_bundles[i]
            return array(0)
        endif
    endloop

    return filenames_bundles
end function


function scalar write_usercode (const string usercode,
                                const string filename_usercode)
    /* Write out script for execution via MPI. */

    catch outfile "@filename_usercode" --quiet
        print  "/* Script created by parallel_specs (gretl) */"
        print usercode
    end outfile

    if $error
        printf "\nError: Failed to write user code to %s.\n", filename_usercode
        return 1
    else
        return 0
    endif
end function


function void invoke_mpi (const int n_jobs_total,
                            const int n_jobs_parallel,
                          const string filename_usercode,
                          const string name_output_bundle,
                          const string name_input_bundle)
    /* Execute MPI part. */

    print "\nInfo: Invoking MPI (this could take a while).\n"
    flush

    scalar n_rounds = ceil(n_jobs_total / n_jobs_parallel)
    scalar offset_job_id = 0

    eval n_jobs_parallel
    execute_mpi(offset_job_id, n_jobs_parallel, filename_usercode, name_output_bundle, name_input_bundle)

    stop

    loop i=1..1 # n_rounds
        printf "\nStart round %d of %d\n", $i, n_rounds
        if i > 1
            offset_job_id += n_jobs_parallel   # update process id
        endif

        execute_mpi(offset_job_id, n_jobs_parallel, filename_usercode, name_output_bundle, name_input_bundle)
    endloop

    print "Info: MPI jobs finished.\n"
end function


function void execute_mpi (const int offset_job_id[0::],
                            const int n_jobs_parallel[1::],
                          const string filename_usercode,
                          const string name_output_bundle,
                          const string name_input_bundle)
    /* Actual execution of MPI job. */

    mpi
        scalar job_id = ($mpirank + 1) + offset_job_id
        print job_id
        stop

        string outname = sprintf("PS_output_%d.txt", job_id)

        outfile "@outname" --quiet
            string bunfile = sprintf("PS_bundle_%d.xml", job_id)
            bundle @name_input_bundle = bread(bunfile)

            run "@filename_usercode"

            # standard closing code
            printf "Info: Computation with argument set %d finished.\n", job_id
            scalar err = bwrite(@name_output_bundle, bunfile)
            if err
                printf "\nError: %s.\n", errmsg(err)
            endif
        end outfile
    end mpi --np=n_jobs_parallel     # --omp-threads=1 (default)
end function


function bundles parallel_specs (const string usercode "Code to execute",
                                 const bundles ArgBundles "Array of bundles holding job arguments",
                                 string name_output_bundle[null] "Bundle to which arguments are passed",
                                 string name_input_bundle[null] "Name of bundle holding job arguments",
                                 int n_jobs_parallel[-1] "No. of jobs to start parallel",
                                 const bool debugging[0])
    /* Parallel execution of code. */
    # TODO: User may want to control the number of CPUs used.

    bundles Bout = null
    scalar n_jobs_total = nelem(ArgBundles)
    string filename_usercode = "PS_script.inp"

    # Run some checks
    if !nelem(ArgBundles)
        printf "\nError: Passed array of bundles is empty.\n"
         return Bout
    endif
    if n_jobs_total < n_jobs_parallel
        printf "\nWarning: Limit number of parallel jobs to %d.\n", n_jobs_total
        scalar n_jobs_parallel = n_jobs_total
    endif

    if n_jobs_parallel == -1
        scalar n_jobs_parallel = $sysinfo.mpimax
    endif

    if !strlen(usercode)
        printf "\nError: Pass some user code.\n"
        return Bout
    endif

    # TODO drop func
    /*
    if njobs_exceeds_nproc(n_jobs_total)     # FIXME: does not print the error
         return Bout
    endif
    */

    if !has_mpi_support()
         return Bout
    endif

    # Create default
    if !exists(name_output_bundle)
        string name_output_bundle = "Mod"		# TODO: more precise default?
    endif
    if !exists(name_input_bundle)
        string name_input_bundle = "Container"			# TODO: 'Arguments'?
    endif

    strings filenames_bundles = write_arg_bundles(ArgBundles)
    if !nelem(filenames_bundles)
       return Bout
    endif

    if write_usercode(usercode, filename_usercode)
        return Bout
    endif

    invoke_mpi(n_jobs_total, n_jobs_parallel, filename_usercode, name_output_bundle, name_input_bundle)
    display_workers_output(n_jobs_total, debugging)
    bundles Bout = create_output_array(filenames_bundles, debugging)
    remove_file(filename_usercode, debugging)

    return Bout
end function


