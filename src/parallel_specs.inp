# hansl code from package parallel_specs 0.1 (2018-06-22)

# private functions

function void display_PS_output (const int n_jobs,
                                 bool debugging)
    print "parallel_specs: MPI finished"
    loop i=1..n_jobs -q
        printf "output for arg set %d:\n", i
        string fname = sprintf("PS_output_%d.txt", i)
        printf "%s", readfile(fname)
        if !debugging
            catch remove(fname)
            if $error
                print "parallel_specs warning: Problem removing temp file"
            endif
        endif
    endloop
end function

function bundles create_PS_array (const int n_jobs,
                                  strings filenames_bundles,
                                  bool debugging)
    print "parallel_specs: assembling bundles for return"
    bundles B = array(n_jobs)
    loop i=1..n_jobs -q
        B[i] = bread(filenames_bundles[i])
        if !debugging
            remove(filenames_bundles[i])
        endif
    endloop
    return B
end function

function scalar has_mpi_support (const int n_jobs)
    /* Check that MPI is installed. */

    if !$sysinfo.mpi
        printf "Error: No MPI support present, Aborting."
        return 0
    else
        return 1
    endif
end function


function scalar n_jobs_exceeds_nproc (const inp n_jobs)
    /* */
# FIXME: Why does this fail? We could loop over subsets of n_jobs
    if n_jobs > $sysinfo.nproc
        printf "Error: Number of bundles passed (%d) exceeds\n\
          available processors (%d), Aborting.", n_jobs, $sysinfo.nproc
        return 1
    else
        return 0
    endif
end function


function strings write_arg_bundles (const bundles ArgBundles)
    /* Write out bundles containing the argument sets.
    return: array of filenames written. */

    strings filenames_bundles = array(nelem(ArgBundles))
    loop foreach i ArgBundles -q
        filenames_bundles[i] = sprintf("PS_bundle_%d.xml", i)
        catch bwrite(ArgBundles[i], filenames_bundles[i])
        
        if $error
            printf "Error: Failed to write bundle %d to\n\
              %s. Abort.", $i, filenames_bundles[i]
            return array(0)
        endif
    endloop
    
    return filenames_bundles
end function


function scalar write_usercode (const string usercode,
                                 const string filename_usercode)
    /* write out script for execution via MPI. */

    catch outfile "@filename_usercode" --quiet
        print  "/* Script created by parallel_specs (gretl) */"
        print usercode
    end outfile
    
    if $error
        printf "Error: Failed to write user code to %s", filename_usercode
        return 1
    else
        return 0
    endif
end function


function bundles parallel_specs (const string usercode "Code to execute",
                                 const bundles ArgBundles "Array of bundles holding job arguments",
                                 string centralbname[null] "????",
                                 string name_arg_bundle[null] "Name of bundle holding job arguments",
                                 const bool debugging[0])
    /* */
    
    bundle Bout = null
    scalar n_jobs = nelem(ArgBundles)
    string filename_usercode = "PS_script.inp"
    
    if !has_mpi_support(n_jobs) || n_jobs_exceeds_nproc(n_jobs)
        return Bout
    endif

    if !exists(centralbname)
        string centralbname = "Mod"			# TODO: think about
    endif
    if !exists(name_arg_bundle)
        string name_arg_bundle = "Container"		# TODO: think about - 'Parameter'
    endif

    strings filenames_bundles = write_arg_bundles(ArgBundles)
    if !nelem(filenames_bundles)
        return Bout
    endif

    if write_usercode(usercode, filename_usercode)
        return Bout
    endif

    ## write out script for exec via MPI
    print "Invoking MPI (this could take a while)"
    flush
    mpi
        ## standard setup code
        scalar i = $mpirank + 1
        # again hardcoded file name!
        string outname = sprintf("PS_output_%d.txt", i)
        outfile @outname --write
        # and again!
        string bunfile = sprintf("PS_bundle_%d.xml", i)
        bundle @name_arg_bundle = bread(bunfile)
        ## end setup code, now idiosyncratic code
        run PS_script.inp # hardcoded fname
        # standard closing code
        printf "Calc with arg set %d complete\n", i
        err = bwrite(@centralbname, bunfile)
        if err
            print "error msg:"
            eval errmsg(err)
        endif
        outfile --close
    end mpi --np=n_jobs
    # present the output from all workers
    display_PS_output(n_jobs, debugging)
    # assemble the return array
    bundles bbout = create_PS_array(n_jobs, filenames_bundles, debugging)
    if !debugging
        remove("PS_script.inp")
    endif
    return bbout
end function
